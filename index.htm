<!DOCTYPE html>
<html>
<head>
    <title>Phaser Mage Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        
        .game-container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-width: 800px;
        }
        
        .title {
            color: #4169E1;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .instruction-text {
            color: #666;
            line-height: 1.5;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
</head>
<body>
    <div class="game-container">
        <div class="title">Spell Casting Game</div>
        <div id="gameCanvas"></div>
        <div class="instructions">
            <div style="color: #4169E1; font-weight: bold; margin-bottom: 10px;">
                You are the BLUE wizard!
            </div>
            <div class="instruction-text">
                • Hold left mouse button to move your character<br>
                • Click on the red enemy to target/untarget them (targeting persists while moving)<br>
                • Press R to cast Magic Arrow while moving (costs 20 mana)<br>
                • Use walls and houses for cover!<br>
                • You can move and cast spells at the same time!
            </div>
        </div>
    </div>

    <script>
    class MainScene extends Phaser.Scene {
        constructor() {
            super({ key: 'MainScene' });
        }

        init() {
            this.GAME_WIDTH = 800;
            this.GAME_HEIGHT = 600;
            this.PLAYER_SIZE = 20;
            this.PLAYER_SPEED = 180;
            
            this.playerStats = {
                health: 100,
                mana: 100
            };
            
            this.enemyStats = {
                health: 100,
                mana: 100
            };
            
            this.selectedTarget = null;
            this.spells = [];
            this.isMoving = false;
        }

        preload() {
            // No assets to preload for this version
        }

        create() {
            // Create game objects
            this.createWorld();
            this.createPlayers();
            this.createUI();
            this.setupInput();
        }

        createWorld() {
            // Create roads (background)
            this.roads = this.add.group();
            [
                { x: 0, y: 200, width: this.GAME_WIDTH, height: 40 },
                { x: 400, y: 0, width: 40, height: this.GAME_HEIGHT }
            ].forEach(road => {
                const roadRect = this.add.rectangle(road.x, road.y, road.width, road.height, 0xA9A9A9);
                roadRect.setOrigin(0, 0);
                this.roads.add(roadRect);
            });

            // Create walls
            this.walls = this.physics.add.staticGroup();
            [
                { x: 200, y: 100, width: 20, height: 200 },
                { x: 500, y: 300, width: 200, height: 20 }
            ].forEach(wall => {
                const wallRect = this.add.rectangle(wall.x, wall.y, wall.width, wall.height, 0x666666);
                wallRect.setOrigin(0, 0);
                this.physics.add.existing(wallRect, true);
                this.walls.add(wallRect);
            });

            // Create houses
            this.houses = this.physics.add.staticGroup();
            [
                { x: 100, y: 100, width: 60, height: 60 },
                { x: 600, y: 400, width: 80, height: 80 }
            ].forEach(house => {
                const houseRect = this.add.rectangle(house.x, house.y, house.width, house.height, 0x8B4513);
                houseRect.setOrigin(0, 0);
                this.physics.add.existing(houseRect, true);
                this.houses.add(houseRect);
            });

            // Create trees
            this.trees = this.add.group();
            [
                { x: 300, y: 150 },
                { x: 450, y: 250 },
                { x: 150, y: 450 }
            ].forEach(tree => {
                const treeCircle = this.add.circle(tree.x, tree.y, 15, 0x228B22);
                this.trees.add(treeCircle);
            });
        }

        createPlayers() {
            // Create player
            this.player = this.add.circle(50, 50, this.PLAYER_SIZE, 0x4169E1);
            this.physics.add.existing(this.player);
            this.player.body.setCollideWorldBounds(true);

            // Create enemy
            this.enemy = this.add.circle(700, 500, this.PLAYER_SIZE, 0x8B0000);
            this.physics.add.existing(this.enemy);
            this.enemy.body.setCollideWorldBounds(true);

            // Add collisions
            this.physics.add.collider(this.player, this.walls);
            this.physics.add.collider(this.player, this.houses);
            this.physics.add.collider(this.enemy, this.walls);
            this.physics.add.collider(this.enemy, this.houses);
        }

        createUI() {
            // Player label
            this.add.text(this.player.x, this.player.y - 35, 'YOU', {
                font: '12px Arial',
                fill: '#000'
            }).setOrigin(0.5);

            // Enemy label
            this.add.text(this.enemy.x, this.enemy.y - 35, 'ENEMY', {
                font: '12px Arial',
                fill: '#000'
            }).setOrigin(0.5);

            // Create health and mana bars
            this.createStatusBars();
        }

        createStatusBars() {
            // Player status bars container
            this.playerBars = this.add.container(this.player.x, this.player.y - 30);
            
            // Player health bar
            this.playerHealthBar = this.add.rectangle(-25, 0, 50, 5, 0x00FF00);
            this.playerHealthBarBg = this.add.rectangle(-25, 0, 50, 5, 0x000000);
            this.playerHealthBarBg.setStrokeStyle(1, 0x000000);
            
            // Player mana bar
            this.playerManaBar = this.add.rectangle(-25, 5, 50, 5, 0x0000FF);
            this.playerManaBarBg = this.add.rectangle(-25, 5, 50, 5, 0x000000);
            this.playerManaBarBg.setStrokeStyle(1, 0x000000);
            
            this.playerBars.add([
                this.playerHealthBarBg,
                this.playerHealthBar,
                this.playerManaBarBg,
                this.playerManaBar
            ]);

            // Enemy status bars container
            this.enemyBars = this.add.container(this.enemy.x, this.enemy.y - 30);
            
            // Enemy health bar
            this.enemyHealthBar = this.add.rectangle(-25, 0, 50, 5, 0x00FF00);
            this.enemyHealthBarBg = this.add.rectangle(-25, 0, 50, 5, 0x000000);
            this.enemyHealthBarBg.setStrokeStyle(1, 0x000000);
            
            // Enemy mana bar
            this.enemyManaBar = this.add.rectangle(-25, 5, 50, 5, 0x0000FF);
            this.enemyManaBarBg = this.add.rectangle(-25, 5, 50, 5, 0x000000);
            this.enemyManaBarBg.setStrokeStyle(1, 0x000000);
            
            this.enemyBars.add([
                this.enemyHealthBarBg,
                this.enemyHealthBar,
                this.enemyManaBarBg,
                this.enemyManaBar
            ]);
        }

        setupInput() {
            // Mouse input
            this.input.on('pointerdown', (pointer) => {
                const distance = Phaser.Math.Distance.Between(
                    pointer.x, pointer.y,
                    this.enemy.x, this.enemy.y
                );

                if (distance < this.PLAYER_SIZE) {
                    this.selectedTarget = this.selectedTarget === this.enemy ? null : this.enemy;
                }
                this.isMoving = true;
            });

            this.input.on('pointerup', () => {
                this.isMoving = false;
            });

            this.input.on('pointermove', (pointer) => {
                this.pointer = pointer;
            });

            // Keyboard input
            this.input.keyboard.on('keydown-R', () => {
                this.castSpell();
            });
        }

        castSpell() {
            if (this.selectedTarget && this.playerStats.mana >= 20) {
                const spell = this.add.circle(this.player.x, this.player.y, 5, 0xFF9900);
                this.physics.add.existing(spell);
                
                const angle = Phaser.Math.Angle.Between(
                    this.player.x, this.player.y,
                    this.selectedTarget.x, this.selectedTarget.y
                );

                this.physics.moveTo(spell, this.selectedTarget.x, this.selectedTarget.y, 300);
                
                this.playerStats.mana -= 20;
                
                // Destroy spell after 1 second
                this.time.delayedCall(1000, () => {
                    spell.destroy();
                });

                // Check for hits
                this.physics.add.overlap(spell, this.selectedTarget, () => {
                    this.enemyStats.health = Math.max(0, this.enemyStats.health - 20);
                    spell.destroy();
                });
            }
        }

        update() {
            // Update player movement
            if (this.isMoving && this.pointer) {
                const angle = Phaser.Math.Angle.Between(
                    this.player.x, this.player.y,
                    this.pointer.x, this.pointer.y
                );
                
                const velocity = new Phaser.Math.Vector2();
                velocity.setToPolar(angle, this.PLAYER_SPEED);
                
                this.player.body.setVelocity(velocity.x, velocity.y);
            } else {
                this.player.body.setVelocity(0, 0);
            }

            // Update status bars position
            this.playerBars.setPosition(this.player.x, this.player.y - 30);
            this.enemyBars.setPosition(this.enemy.x, this.enemy.y - 30);

            // Update status bars scale
            this.playerHealthBar.scaleX = this.playerStats.health / 100;
            this.playerManaBar.scaleX = this.playerStats.mana / 100;
            this.enemyHealthBar.scaleX = this.enemyStats.health / 100;
            this.enemyManaBar.scaleX = this.enemyStats.mana / 100;

            // Regenerate health and mana
            this.playerStats.health = Math.min(100, this.playerStats.health + 0.1);
            this.playerStats.mana = Math.min(100, this.playerStats.mana + 0.2);
            this.enemyStats.health = Math.min(100, this.enemyStats.health + 0.1);
            this.enemyStats.mana = Math.min(100, this.enemyStats.mana + 0.2);

            // Update targeting indicator
            if (this.selectedTarget) {
                this.updateTargetingIndicator();
            }
        }

        updateTargetingIndicator() {
            // Remove previous targeting indicator if it exists
            if (this.targetingIndicator) {
                this.targetingIndicator.destroy();
            }

            const graphics = this.add.graphics();
            graphics.lineStyle(2, 0xFF0000);

            // Draw pulsing circle
            const time = this.time.now * 0.003;
            const size = this.PLAYER_SIZE + 5 + Math.sin(time) * 3;
            graphics.strokeCircle(this.selectedTarget.x, this.selectedTarget.y, size);

            // Draw crosshair
            const crosshairSize = 10;
            graphics.moveTo(this.selectedTarget.x - crosshairSize, this.selectedTarget.y);
            graphics.lineTo(this.selectedTarget.x + crosshairSize, this.selectedTarget.y);
            graphics.moveTo(this.selectedTarget.x, this.selectedTarget.y - crosshairSize);
            graphics.lineTo(this.selectedTarget.x, this.selectedTarget.y + crosshairSize);
            graphics.strokePath();

            this.targetingIndicator = graphics;
        }
    }

    const config = {
        type: Phaser.AUTO,
        parent: 'gameCanvas',
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 },
                debug: false
            }
        },
        scene: MainScene
    };

    const game = new Phaser.Game(config);
    </script>
</body>
</html>