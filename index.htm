<!DOCTYPE html>
<html>
<head>
    <title>Phaser Mage Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        
        .game-container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-width: 800px;
        }
        
        .title {
            color: #4169E1;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .instruction-text {
            color: #666;
            line-height: 1.5;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
</head>
<body>
    <div class="game-container">
        <div class="title">Spell Casting Game</div>
        <div id="gameCanvas"></div>
        <div class="instructions">
            <div style="color: #4169E1; font-weight: bold; margin-bottom: 10px;">
                You are the BLUE wizard!
            </div>
            <div class="instruction-text">
                • Hold left mouse button to move your character<br>
                • Click on the red enemy to target/untarget them (targeting persists while moving)<br>
                • Press R to cast Magic Arrow while moving (costs 20 mana)<br>
                • Use walls and houses for cover - spells can't pass through them!<br>
                • You can move and cast spells at the same time!<br>
                • Be careful not to cast too quickly or your spell will fizzle!
            </div>
        </div>
    </div>

    <script>

class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
    }

    init() {
        this.GAME_WIDTH = 800;
        this.GAME_HEIGHT = 600;
        this.PLAYER_SIZE = 20;
        this.PLAYER_SPEED = 180;
        this.lastCastTime = 0;
        
        this.playerStats = {
            health: 100,
            mana: 100
        };
        
        this.enemyStats = {
            health: 100,
            mana: 100
        };
        
        this.selectedTarget = null;
        this.spells = [];
        this.isMoving = false;
    }

    preload() {
        // Load textures for ground, walls, and characters
        this.load.image('grass', 'https://opengameart.org/sites/default/files/styles/medium/public/dirt_16.png');
        this.load.image('road', 'https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/assets/road.png');
        this.load.image('wall', 'https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/assets/wall.png');
        this.load.image('tree', 'https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/assets/tree.png');
        this.load.image('house', 'https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/assets/house.png');
        this.load.image('mage-blue', 'https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/assets/mage-blue.png');
        this.load.image('mage-red', 'https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/assets/mage-red.png');
    }

    create() {
        // Create game objects
        this.createWorld();
        this.createPlayers();
        this.createUI();
        this.setupInput();
    }

    createWorld() {
        // Create tiled ground
        const groundTiles = this.add.tileSprite(0, 0, this.GAME_WIDTH, this.GAME_HEIGHT, 'grass');
        groundTiles.setOrigin(0, 0);
        groundTiles.setDepth(0);

        // Create roads with textured sprites
        this.roads = this.add.group();
        [
            { x: 0, y: 200, width: this.GAME_WIDTH, height: 40 },
            { x: 400, y: 0, width: 40, height: this.GAME_HEIGHT }
        ].forEach(road => {
            const roadSprite = this.add.tileSprite(road.x, road.y, road.width, road.height, 'road');
            roadSprite.setOrigin(0, 0);
            roadSprite.setDepth(1);
            this.roads.add(roadSprite);
        });

        // Create textured walls
        this.walls = this.physics.add.staticGroup();
        [
            { x: 200, y: 100, width: 20, height: 200 },
            { x: 500, y: 300, width: 200, height: 20 }
        ].forEach(wall => {
            const wallSprite = this.add.tileSprite(wall.x, wall.y, wall.width, wall.height, 'wall');
            wallSprite.setOrigin(0, 0);
            wallSprite.setDepth(2);
            this.physics.add.existing(wallSprite, true);
            this.walls.add(wallSprite);
        });

        // Create houses with sprites
        this.houses = this.physics.add.staticGroup();
        [
            { x: 100, y: 100, scale: 1.2 },
            { x: 600, y: 400, scale: 1.5 }
        ].forEach(house => {
            const houseSprite = this.add.sprite(house.x, house.y, 'house');
            houseSprite.setScale(house.scale);
            houseSprite.setDepth(2);
            this.physics.add.existing(houseSprite, true);
            this.houses.add(houseSprite);
        });

        // Create trees with sprites and shadows
        this.trees = this.add.group();
        [
            { x: 300, y: 150, scale: 1 },
            { x: 450, y: 250, scale: 1.2 },
            { x: 150, y: 450, scale: 0.9 }
        ].forEach(tree => {
            // Add shadow
            const shadow = this.add.ellipse(tree.x + 5, tree.y + 5, 30, 15, 0x000000, 0.3);
            shadow.setDepth(1);

            // Add tree sprite
            const treeSprite = this.add.sprite(tree.x, tree.y, 'tree');
            treeSprite.setScale(tree.scale);
            treeSprite.setDepth(3);
            this.trees.add(treeSprite);
        });
    }
   
    

    createPlayers() {
        // Create player mage with sprite
        this.player = this.add.sprite(50, 50, 'mage-blue');
        this.player.setScale(0.8);
        this.player.setDepth(4);
        this.physics.add.existing(this.player);
        this.player.body.setCollideWorldBounds(true);
        
        // Add player shadow
        this.playerShadow = this.add.ellipse(50, 55, 30, 15, 0x000000, 0.3);
        this.playerShadow.setDepth(3);

        // Create enemy mage with sprite
        this.enemy = this.add.sprite(700, 500, 'mage-red');
        this.enemy.setScale(0.8);
        this.enemy.setDepth(4);
        this.physics.add.existing(this.enemy);
        this.enemy.body.setCollideWorldBounds(true);
        
        // Add enemy shadow
        this.enemyShadow = this.add.ellipse(700, 505, 30, 15, 0x000000, 0.3);
        this.enemyShadow.setDepth(3);

        // Add collisions
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.player, this.houses);
        this.physics.add.collider(this.enemy, this.walls);
        this.physics.add.collider(this.enemy, this.houses);
    }

    createUI() {
        // Player label
        this.add.text(this.player.x, this.player.y - 35, 'YOU', {
            font: '12px Arial',
            fill: '#000'
        }).setOrigin(0.5);

        // Enemy label
        this.add.text(this.enemy.x, this.enemy.y - 35, 'ENEMY', {
            font: '12px Arial',
            fill: '#000'
        }).setOrigin(0.5);

        // Create health and mana bars
        this.createStatusBars();
    }

    createStatusBars() {
        // Player status bars container
        this.playerBars = this.add.container(this.player.x, this.player.y - 40);
        
        // Player health bar
        this.playerHealthBar = this.add.rectangle(-25, 0, 50, 5, 0x00FF00);
        this.playerHealthBarBg = this.add.rectangle(-25, 0, 50, 5, 0x000000);
        this.playerHealthBarBg.setStrokeStyle(1, 0x000000);
        
        // Player mana bar
        this.playerManaBar = this.add.rectangle(-25, 5, 50, 5, 0x0000FF);
        this.playerManaBarBg = this.add.rectangle(-25, 5, 50, 5, 0x000000);
        this.playerManaBarBg.setStrokeStyle(1, 0x000000);
        
        this.playerBars.add([
            this.playerHealthBarBg,
            this.playerHealthBar,
            this.playerManaBarBg,
            this.playerManaBar
        ]);

        // Enemy status bars container
        this.enemyBars = this.add.container(this.enemy.x, this.enemy.y - 40);
        
        // Enemy health bar
        this.enemyHealthBar = this.add.rectangle(-25, 0, 50, 5, 0x00FF00);
        this.enemyHealthBarBg = this.add.rectangle(-25, 0, 50, 5, 0x000000);
        this.enemyHealthBarBg.setStrokeStyle(1, 0x000000);
        
        // Enemy mana bar
        this.enemyManaBar = this.add.rectangle(-25, 5, 50, 5, 0x0000FF);
        this.enemyManaBarBg = this.add.rectangle(-25, 5, 50, 5, 0x000000);
        this.enemyManaBarBg.setStrokeStyle(1, 0x000000);
        
        this.enemyBars.add([
            this.enemyHealthBarBg,
            this.enemyHealthBar,
            this.enemyManaBarBg,
            this.enemyManaBar
        ]);
    }

    setupInput() {
        // Mouse input
        this.input.on('pointerdown', (pointer) => {
            const distance = Phaser.Math.Distance.Between(
                pointer.x, pointer.y,
                this.enemy.x, this.enemy.y
            );

            if (distance < this.PLAYER_SIZE) {
                this.selectedTarget = this.selectedTarget === this.enemy ? null : this.enemy;
            }
            this.isMoving = true;
        });

        this.input.on('pointerup', () => {
            this.isMoving = false;
        });

        this.input.on('pointermove', (pointer) => {
            this.pointer = pointer;
        });

        // Keyboard input
        this.input.keyboard.on('keydown-R', () => {
            this.castSpell();
        });
    }

    castSpell() {
        // Check if already casting or not enough mana
        if (!this.selectedTarget || this.playerStats.mana < 20) {
            return;
        }

        // Get current time
        const currentTime = this.time.now;
        
        // Check if casting too fast (before previous cast completed)
        if (this.isCasting) {
            // Create fizzle effect at player position
            this.createFizzleEffect(this.player.x, this.player.y);
            return;
        }

        // Check if we need to wait for cooldown
        if (this.lastCastTime && currentTime - this.lastCastTime < 700) {
            // Create fizzle effect at player position to show failed cast
            this.createFizzleEffect(this.player.x, this.player.y);
            return;
        }

        this.isCasting = true;
        this.lastCastTime = currentTime;

        // Create casting circle indicator
        const castingCircle = this.add.circle(this.player.x, this.player.y, this.PLAYER_SIZE + 5, 0xFF9900, 0.3);
        
        // Start casting animation
        this.tweens.add({
            targets: castingCircle,
            alpha: 0.6,
            yoyo: true,
            repeat: 2,  // Will create a pulsing effect during cast time
            duration: 350,  // Half of total cast time for smooth pulsing
            onComplete: () => {
                castingCircle.destroy();
            }
        });

        // After cast time, launch the spell
        this.time.delayedCall(700, () => {  // 700ms = 0.7 seconds
            if (this.selectedTarget && this.selectedTarget.active) {  // Check if target still exists
                const spell = this.add.circle(this.player.x, this.player.y, 5, 0xFF9900);
                this.physics.add.existing(spell);
                
                const angle = Phaser.Math.Angle.Between(
                    this.player.x, this.player.y,
                    this.selectedTarget.x, this.selectedTarget.y
                );

                this.physics.moveTo(spell, this.selectedTarget.x, this.selectedTarget.y, 300);
                
                this.playerStats.mana -= 20;
                
                // Add collision with walls and houses
                this.physics.add.collider(spell, this.walls, (spellObj) => {
                    this.createFizzleEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });
                
                this.physics.add.collider(spell, this.houses, (spellObj) => {
                    this.createFizzleEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });

                // Check for hits on target
                this.physics.add.overlap(spell, this.selectedTarget, (spellObj) => {
                    this.enemyStats.health = Math.max(0, this.enemyStats.health - 20);
                    this.createFizzleEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });

                // Destroy spell after 1 second if it hasn't hit anything
                this.time.delayedCall(1000, () => {
                    if (spell.active) {
                        this.createFizzleEffect(spell.x, spell.y);
                        spell.destroy();
                    }
                });
            }
            
            this.isCasting = false;
        });
    }

    createFizzleEffect(x, y) {
        // Create particles for fizzle effect
        const particles = this.add.particles(x, y, {
            speed: 100,
            scale: { start: 0.5, end: 0 },
            quantity: 5,
            lifespan: 300,
            tint: 0xFF9900
        });

        // Destroy particles after animation completes
        this.time.delayedCall(300, () => {
            particles.destroy();
        });
    }

    updateTargetingIndicator() {
        // Remove previous targeting indicator if it exists
        if (this.targetingIndicator) {
            this.targetingIndicator.destroy();
        }

        const graphics = this.add.graphics();
        graphics.lineStyle(2, 0xFF0000);

        // Draw pulsing circle
        const time = this.time.now * 0.003;
        const size = this.PLAYER_SIZE + 5 + Math.sin(time) * 3;
        graphics.strokeCircle(this.selectedTarget.x, this.selectedTarget.y, size);

        // Draw crosshair
        const crosshairSize = 10;
        graphics.moveTo(this.selectedTarget.x - crosshairSize, this.selectedTarget.y);
        graphics.lineTo(this.selectedTarget.x + crosshairSize, this.selectedTarget.y);
        graphics.moveTo(this.selectedTarget.x, this.selectedTarget.y - crosshairSize);
        graphics.lineTo(this.selectedTarget.x, this.selectedTarget.y + crosshairSize);
        graphics.strokePath();

        this.targetingIndicator = graphics;
    }

    update() {
        // Update player movement
        if (this.isMoving && this.pointer) {
            const distance = Phaser.Math.Distance.Between(
                this.player.x, this.player.y,
                this.pointer.x, this.pointer.y
            );
            
            if (distance > this.PLAYER_SIZE) {
                const angle = Phaser.Math.Angle.Between(
                    this.player.x, this.player.y,
                    this.pointer.x, this.pointer.y
                );
                
                const velocity = new Phaser.Math.Vector2();
                velocity.setToPolar(angle, this.PLAYER_SPEED);
                
                this.player.body.setVelocity(velocity.x, velocity.y);
                
                // Update player shadow position
                this.playerShadow.setPosition(this.player.x + 5, this.player.y + 5);
            } else {
                this.player.body.setVelocity(0, 0);
            }
        } else {
            this.player.body.setVelocity(0, 0);
        }

        // Update enemy shadow position
        this.enemyShadow.setPosition(this.enemy.x + 5, this.enemy.y + 5);

        // Update status bars position
        this.playerBars.setPosition(this.player.x, this.player.y - 40);
        this.enemyBars.setPosition(this.enemy.x, this.enemy.y - 40);

        // Update status bars scale
        this.playerHealthBar.scaleX = this.playerStats.health / 100;
        this.playerManaBar.scaleX = this.playerStats.mana / 100;
        this.enemyHealthBar.scaleX = this.enemyStats.health / 100;
        this.enemyManaBar.scaleX = this.enemyStats.mana / 100;

        // Regenerate health and mana
        this.playerStats.health = Math.min(100, this.playerStats.health + 0.1);
        this.playerStats.mana = Math.min(100, this.playerStats.mana + 0.2);
        this.enemyStats.health = Math.min(100, this.enemyStats.health + 0.1);
        this.enemyStats.mana = Math.min(100, this.enemyStats.mana + 0.2);

        // Update targeting indicator
        if (this.selectedTarget) {
            this.updateTargetingIndicator();
        }
    }
}

const config = {
    type: Phaser.AUTO,
    parent: 'gameCanvas',
    width: 800,
    height: 600,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false
        }
    },
    scene: MainScene
};

const game = new Phaser.Game(config);
</script>
</body>
</html>