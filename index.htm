<!DOCTYPE html>
<html>
<head>
    <title>Phaser Mage Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: black;
        }
        #gameCanvas {
            width: 100vw;
            height: 100vh;
        }
        .menu-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            z-index: 1000;
        }
        .menu-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            max-width: 400px;
            display: none;
            z-index: 1000;
        }
        .menu-title {
            color: #4169E1;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        .menu-content {
            color: #fff;
            line-height: 1.6;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
</head>
<body>
    <div id="gameCanvas"></div>
    <button class="menu-button">☰ Menu</button>
    <div class="menu-panel">
        <div class="menu-title">Game Controls</div>
        <div class="menu-content">
            <strong style="color: #4169E1;">You are the BLUE wizard!</strong><br><br>
            • Hold left mouse button to move your character<br>
            • Click on the red enemy to target/untarget them (targeting persists while moving)<br>
            • Press R to cast Magic Arrow while moving (costs 20 mana)<br>
            • Press T to cast Lightning while moving (costs 30 mana)<br>
            • Press F to cast Flame Strike while moving (costs 40 mana)<br>
            • Use walls and houses for cover - spells can't pass through them!<br>
            • You can move and cast spells at the same time!<br>
            • Be careful not to cast too quickly or your spell will fizzle!
        </div>
    </div>

    <script>
        // Menu toggle functionality
        document.querySelector('.menu-button').addEventListener('click', () => {
            const menu = document.querySelector('.menu-panel');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        });
    </script>

    <script>

class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
    }

    init() {
        this.GAME_WIDTH = 800;
        this.GAME_HEIGHT = 600;
        this.PLAYER_SIZE = 20;
        this.PLAYER_SPEED = 180;
        this.lastCastTime = 0;
        
        this.playerStats = {
            health: 100,
            mana: 100
        };
        
        this.enemyStats = {
            health: 100,
            mana: 100
        };
        
        this.selectedTarget = null;
        this.spells = [];
        this.isMoving = false;
    }

    preload() {
        // Create a grass pattern texture programmatically
        const grassTexture = this.textures.createCanvas('grass', 32, 32);
        const ctx = grassTexture.getContext();
        
        // Fill base color
        ctx.fillStyle = '#2d5a27';
        ctx.fillRect(0, 0, 32, 32);
        
        // Add noise pattern
        const imageData = ctx.getImageData(0, 0, 32, 32);
        for (let i = 0; i < imageData.data.length; i += 4) {
            const noise = Math.random() * 20 - 10;
            imageData.data[i] = Math.max(0, Math.min(255, imageData.data[i] + noise));
            imageData.data[i + 1] = Math.max(0, Math.min(255, imageData.data[i + 1] + noise));
            imageData.data[i + 2] = Math.max(0, Math.min(255, imageData.data[i + 2] + noise));
        }
        ctx.putImageData(imageData, 0, 0);
        
        // Add grass blades with varied angles and lengths
        ctx.strokeStyle = '#1e3f1c';
        ctx.lineWidth = 1;
        
        // Add darker grass blades
        for (let i = 0; i < 12; i++) {
            const x = Math.random() * 32;
            const y = Math.random() * 32;
            const length = 6 + Math.random() * 4;
            const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.8;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(
                x + Math.cos(angle) * length,
                y + Math.sin(angle) * length
            );
            ctx.stroke();
        }
        
        // Add lighter grass blades for contrast
        ctx.strokeStyle = '#3a7033';
        for (let i = 0; i < 8; i++) {
            const x = Math.random() * 32;
            const y = Math.random() * 32;
            const length = 4 + Math.random() * 3;
            const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.6;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(
                x + Math.cos(angle) * length,
                y + Math.sin(angle) * length
            );
            ctx.stroke();
        }
        
        grassTexture.refresh();
    }

    create() {
        // Create game objects
        this.createWorld();
        this.createPlayers();
        this.createUI();
        this.setupInput();
    }

    createWorld() {
        // Create tiled grass ground
        const groundTiles = this.add.tileSprite(0, 0, this.GAME_WIDTH, this.GAME_HEIGHT, 'grass');
        groundTiles.setOrigin(0, 0);
        groundTiles.setDepth(0);

        // Create simple walls as rectangles
        this.walls = this.physics.add.staticGroup();
        [
            { x: 200, y: 100, width: 20, height: 200 },
            { x: 500, y: 300, width: 200, height: 20 }
        ].forEach(wall => {
            const wallRect = this.add.rectangle(wall.x, wall.y, wall.width, wall.height, 0x808080);
            wallRect.setOrigin(0, 0);
            wallRect.setDepth(2);
            this.physics.add.existing(wallRect, true);
            this.walls.add(wallRect);
        });

        // Create simple houses as rectangles
        this.houses = this.physics.add.staticGroup();
        [
            { x: 100, y: 100, width: 60, height: 60 },
            { x: 600, y: 400, width: 80, height: 80 }
        ].forEach(house => {
            const houseRect = this.add.rectangle(house.x, house.y, house.width, house.height, 0xA0522D);
            houseRect.setOrigin(0, 0);
            houseRect.setDepth(2);
            this.physics.add.existing(houseRect, true);
            this.houses.add(houseRect);
        });

        // Create simple trees as circles
        this.trees = this.add.group();
        [
            { x: 300, y: 150, radius: 20 },
            { x: 450, y: 250, radius: 25 },
            { x: 150, y: 450, radius: 18 }
        ].forEach(tree => {
            // Add shadow
            const shadow = this.add.ellipse(tree.x + 5, tree.y + 5, tree.radius * 2, tree.radius, 0x000000, 0.3);
            shadow.setDepth(1);

            // Add tree
            const treeCircle = this.add.circle(tree.x, tree.y, tree.radius, 0x228B22);
            treeCircle.setDepth(3);
            this.trees.add(treeCircle);
        });
    }
   
    

    createPlayers() {
        // Create player as a blue circle
        this.player = this.add.circle(50, 50, 15, 0x0000FF);
        this.player.setDepth(4);
        this.physics.add.existing(this.player);
        this.player.body.setCollideWorldBounds(true);
        
        // Add player shadow
        this.playerShadow = this.add.ellipse(50, 55, 30, 15, 0x000000, 0.3);
        this.playerShadow.setDepth(3);

        // Create enemy as a red circle
        this.enemy = this.add.circle(700, 500, 15, 0xFF0000);
        this.enemy.setDepth(4);
        this.physics.add.existing(this.enemy);
        this.enemy.body.setCollideWorldBounds(true);
        
        // Add enemy shadow
        this.enemyShadow = this.add.ellipse(700, 505, 30, 15, 0x000000, 0.3);
        this.enemyShadow.setDepth(3);

        // Initialize enemy AI properties
        this.enemy.lastCastTime = 0;
        this.enemy.isCasting = false;
        this.enemy.nextSpellTime = 0;
        this.enemy.avoidanceTimer = 0;
        this.enemy.currentTarget = this.player;

        // Add collisions
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.player, this.houses);
        this.physics.add.collider(this.enemy, this.walls);
        this.physics.add.collider(this.enemy, this.houses);

        // Track active spells for avoidance
        this.activeSpells = this.add.group();
    }

    createUI() {
        // Player label
        this.add.text(this.player.x, this.player.y - 35, 'YOU', {
            font: '12px Arial',
            fill: '#000'
        }).setOrigin(0.5);

        // Enemy label
        this.add.text(this.enemy.x, this.enemy.y - 35, 'ENEMY', {
            font: '12px Arial',
            fill: '#000'
        }).setOrigin(0.5);

        // Create health and mana bars
        this.createStatusBars();
    }

    createStatusBars() {
        // Player status bars container
        this.playerBars = this.add.container(this.player.x, this.player.y - 40);
        
        // Player health bar
        this.playerHealthBar = this.add.rectangle(-25, 0, 50, 5, 0x00FF00);
        this.playerHealthBarBg = this.add.rectangle(-25, 0, 50, 5, 0x000000);
        this.playerHealthBarBg.setStrokeStyle(1, 0x000000);
        
        // Player mana bar
        this.playerManaBar = this.add.rectangle(-25, 5, 50, 5, 0x0000FF);
        this.playerManaBarBg = this.add.rectangle(-25, 5, 50, 5, 0x000000);
        this.playerManaBarBg.setStrokeStyle(1, 0x000000);
        
        this.playerBars.add([
            this.playerHealthBarBg,
            this.playerHealthBar,
            this.playerManaBarBg,
            this.playerManaBar
        ]);

        // Enemy status bars container
        this.enemyBars = this.add.container(this.enemy.x, this.enemy.y - 40);
        
        // Enemy health bar
        this.enemyHealthBar = this.add.rectangle(-25, 0, 50, 5, 0x00FF00);
        this.enemyHealthBarBg = this.add.rectangle(-25, 0, 50, 5, 0x000000);
        this.enemyHealthBarBg.setStrokeStyle(1, 0x000000);
        
        // Enemy mana bar
        this.enemyManaBar = this.add.rectangle(-25, 5, 50, 5, 0x0000FF);
        this.enemyManaBarBg = this.add.rectangle(-25, 5, 50, 5, 0x000000);
        this.enemyManaBarBg.setStrokeStyle(1, 0x000000);
        
        this.enemyBars.add([
            this.enemyHealthBarBg,
            this.enemyHealthBar,
            this.enemyManaBarBg,
            this.enemyManaBar
        ]);
    }

    setupInput() {
        // Mouse input
        this.input.on('pointerdown', (pointer) => {
            const distance = Phaser.Math.Distance.Between(
                pointer.x, pointer.y,
                this.enemy.x, this.enemy.y
            );

            if (distance < this.PLAYER_SIZE) {
                this.selectedTarget = this.selectedTarget === this.enemy ? null : this.enemy;
            }
            this.isMoving = true;
        });

        this.input.on('pointerup', () => {
            this.isMoving = false;
        });

        this.input.on('pointermove', (pointer) => {
            this.pointer = pointer;
        });

        // Keyboard input
        this.input.keyboard.on('keydown-R', () => {
            this.castSpell();
        });
        
        this.input.keyboard.on('keydown-T', () => {
            this.castLightningSpell();
        });

        this.input.keyboard.on('keydown-F', () => {
            this.castFlameStrikeSpell();
        });
    }

    castLightningSpell() {
        // Check if already casting or not enough mana
        if (!this.selectedTarget || this.playerStats.mana < 30) {
            return;
        }

        // Get current time
        const currentTime = this.time.now;
        
        // Check if casting too fast (before previous cast completed)
        if (this.isCasting) {
            // Create fizzle effect at player position
            this.createFizzleEffect(this.player.x, this.player.y);
            return;
        }

        // Check if we need to wait for cooldown
        if (this.lastCastTime && currentTime - this.lastCastTime < 900) {
            // Create fizzle effect at player position to show failed cast
            this.createFizzleEffect(this.player.x, this.player.y);
            return;
        }

        this.isCasting = true;
        this.lastCastTime = currentTime;

        // Create casting circle indicator with lightning color
        const castingCircle = this.add.circle(this.player.x, this.player.y, this.PLAYER_SIZE + 5, 0x00FFFF, 0.3);
        
        // Start casting animation
        this.tweens.add({
            targets: castingCircle,
            alpha: 0.6,
            yoyo: true,
            repeat: 2,
            duration: 450,
            onComplete: () => {
                castingCircle.destroy();
            }
        });

        // After cast time, launch the spell
        this.time.delayedCall(900, () => {
            if (this.selectedTarget && this.selectedTarget.active) {
                const spell = this.add.circle(this.player.x, this.player.y, 7, 0x00FFFF);
                this.physics.add.existing(spell);
                
                const angle = Phaser.Math.Angle.Between(
                    this.player.x, this.player.y,
                    this.selectedTarget.x, this.selectedTarget.y
                );

                this.physics.moveTo(spell, this.selectedTarget.x, this.selectedTarget.y, 400);
                
                this.playerStats.mana -= 30;
                
                // Add collision with walls and houses
                this.physics.add.collider(spell, this.walls, (spellObj) => {
                    this.createLightningEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });
                
                this.physics.add.collider(spell, this.houses, (spellObj) => {
                    this.createLightningEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });

                // Check for hits on target
                this.physics.add.overlap(spell, this.selectedTarget, (spellObj) => {
                    this.enemyStats.health = Math.max(0, this.enemyStats.health - 35);
                    this.createLightningEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });

                // Destroy spell after 1 second if it hasn't hit anything
                this.time.delayedCall(1000, () => {
                    if (spell.active) {
                        this.createLightningEffect(spell.x, spell.y);
                        spell.destroy();
                    }
                });
            }
            
            this.isCasting = false;
        });
    }

    castFlameStrikeSpell() {
        // Check if already casting or not enough mana
        if (!this.selectedTarget || this.playerStats.mana < 40) {
            return;
        }

        // Get current time
        const currentTime = this.time.now;
        
        // Check if casting too fast (before previous cast completed)
        if (this.isCasting) {
            // Create fizzle effect at player position
            this.createFizzleEffect(this.player.x, this.player.y);
            return;
        }

        // Check if we need to wait for cooldown
        if (this.lastCastTime && currentTime - this.lastCastTime < 1200) {
            // Create fizzle effect at player position to show failed cast
            this.createFizzleEffect(this.player.x, this.player.y);
            return;
        }

        this.isCasting = true;
        this.lastCastTime = currentTime;

        // Create casting circle indicator with flame colors
        const castingCircle = this.add.circle(this.player.x, this.player.y, this.PLAYER_SIZE + 5, 0xFF4500, 0.3);
        
        // Start casting animation
        this.tweens.add({
            targets: castingCircle,
            alpha: 0.6,
            yoyo: true,
            repeat: 3,
            duration: 400,
            onComplete: () => {
                castingCircle.destroy();
            }
        });

        // After cast time, launch the spell
        this.time.delayedCall(1200, () => {
            if (this.selectedTarget && this.selectedTarget.active) {
                const spell = this.add.circle(this.player.x, this.player.y, 10, 0xFF4500);
                this.physics.add.existing(spell);
                
                const angle = Phaser.Math.Angle.Between(
                    this.player.x, this.player.y,
                    this.selectedTarget.x, this.selectedTarget.y
                );

                this.physics.moveTo(spell, this.selectedTarget.x, this.selectedTarget.y, 350);
                
                this.playerStats.mana -= 40;
                
                // Add collision with walls and houses
                this.physics.add.collider(spell, this.walls, (spellObj) => {
                    this.createFlameEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });
                
                this.physics.add.collider(spell, this.houses, (spellObj) => {
                    this.createFlameEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });

                // Check for hits on target
                this.physics.add.overlap(spell, this.selectedTarget, (spellObj) => {
                    this.enemyStats.health = Math.max(0, this.enemyStats.health - 45);
                    this.createFlameEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });

                // Destroy spell after 1 second if it hasn't hit anything
                this.time.delayedCall(1000, () => {
                    if (spell.active) {
                        this.createFlameEffect(spell.x, spell.y);
                        spell.destroy();
                    }
                });
            }
            
            this.isCasting = false;
        });
    }

    createFlameEffect(x, y) {
        // Create flame particles
        const particles = this.add.particles(x, y, {
            speed: { min: 100, max: 200 },
            scale: { start: 0.8, end: 0 },
            quantity: 12,
            lifespan: 600,
            tint: [0xFF4500, 0xFF6B00, 0xFF8C00],
            angle: { min: 0, max: 360 }
        });

        // Create a flame burst effect
        const burst = this.add.circle(x, y, 25, 0xFF4500, 0.7);
        this.tweens.add({
            targets: burst,
            alpha: 0,
            scale: 1.8,
            duration: 300,
            onComplete: () => {
                burst.destroy();
            }
        });

        // Destroy particles after animation completes
        this.time.delayedCall(600, () => {
            particles.destroy();
        });
    }

    createLightningEffect(x, y) {
        // Create lightning particles
        const particles = this.add.particles(x, y, {
            speed: 150,
            scale: { start: 0.7, end: 0 },
            quantity: 8,
            lifespan: 400,
            tint: 0x00FFFF,
            angle: { min: 0, max: 360 }
        });

        // Create a flash effect
        const flash = this.add.circle(x, y, 20, 0x00FFFF, 0.6);
        this.tweens.add({
            targets: flash,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            onComplete: () => {
                flash.destroy();
            }
        });

        // Destroy particles after animation completes
        this.time.delayedCall(400, () => {
            particles.destroy();
        });
    }

    castSpell() {
        // Check if already casting or not enough mana
        if (!this.selectedTarget || this.playerStats.mana < 20) {
            return;
        }

        // Get current time
        const currentTime = this.time.now;
        
        // Check if casting too fast (before previous cast completed)
        if (this.isCasting) {
            // Create fizzle effect at player position
            this.createFizzleEffect(this.player.x, this.player.y);
            return;
        }

        // Check if we need to wait for cooldown
        if (this.lastCastTime && currentTime - this.lastCastTime < 700) {
            // Create fizzle effect at player position to show failed cast
            this.createFizzleEffect(this.player.x, this.player.y);
            return;
        }

        this.isCasting = true;
        this.lastCastTime = currentTime;

        // Create casting circle indicator
        const castingCircle = this.add.circle(this.player.x, this.player.y, this.PLAYER_SIZE + 5, 0xFF9900, 0.3);
        
        // Start casting animation
        this.tweens.add({
            targets: castingCircle,
            alpha: 0.6,
            yoyo: true,
            repeat: 2,  // Will create a pulsing effect during cast time
            duration: 350,  // Half of total cast time for smooth pulsing
            onComplete: () => {
                castingCircle.destroy();
            }
        });

        // After cast time, launch the spell
        this.time.delayedCall(700, () => {  // 700ms = 0.7 seconds
            if (this.selectedTarget && this.selectedTarget.active) {  // Check if target still exists
                const spell = this.add.circle(this.player.x, this.player.y, 5, 0xFF9900);
                this.physics.add.existing(spell);
                
                const angle = Phaser.Math.Angle.Between(
                    this.player.x, this.player.y,
                    this.selectedTarget.x, this.selectedTarget.y
                );

                this.physics.moveTo(spell, this.selectedTarget.x, this.selectedTarget.y, 300);
                
                this.playerStats.mana -= 20;
                
                // Add collision with walls and houses
                this.physics.add.collider(spell, this.walls, (spellObj) => {
                    this.createFizzleEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });
                
                this.physics.add.collider(spell, this.houses, (spellObj) => {
                    this.createFizzleEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });

                // Check for hits on target
                this.physics.add.overlap(spell, this.selectedTarget, (spellObj) => {
                    this.enemyStats.health = Math.max(0, this.enemyStats.health - 20);
                    this.createFizzleEffect(spellObj.x, spellObj.y);
                    spellObj.destroy();
                });

                // Destroy spell after 1 second if it hasn't hit anything
                this.time.delayedCall(1000, () => {
                    if (spell.active) {
                        this.createFizzleEffect(spell.x, spell.y);
                        spell.destroy();
                    }
                });
            }
            
            this.isCasting = false;
        });
    }

    createFizzleEffect(x, y) {
        // Create particles for fizzle effect
        const particles = this.add.particles(x, y, {
            speed: 100,
            scale: { start: 0.5, end: 0 },
            quantity: 5,
            lifespan: 300,
            tint: 0xFF9900
        });

        // Destroy particles after animation completes
        this.time.delayedCall(300, () => {
            particles.destroy();
        });
    }

    updateTargetingIndicator() {
        // Remove previous targeting indicator if it exists
        if (this.targetingIndicator) {
            this.targetingIndicator.destroy();
        }

        const graphics = this.add.graphics();
        graphics.lineStyle(2, 0xFF0000);

        // Draw pulsing circle
        const time = this.time.now * 0.003;
        const size = this.PLAYER_SIZE + 5 + Math.sin(time) * 3;
        graphics.strokeCircle(this.selectedTarget.x, this.selectedTarget.y, size);

        // Draw crosshair
        const crosshairSize = 10;
        graphics.moveTo(this.selectedTarget.x - crosshairSize, this.selectedTarget.y);
        graphics.lineTo(this.selectedTarget.x + crosshairSize, this.selectedTarget.y);
        graphics.moveTo(this.selectedTarget.x, this.selectedTarget.y - crosshairSize);
        graphics.lineTo(this.selectedTarget.x, this.selectedTarget.y + crosshairSize);
        graphics.strokePath();

        this.targetingIndicator = graphics;
    }

    enemyCastSpell() {
        if (this.enemy.isCasting || this.enemyStats.mana < 20 || this.time.now < this.enemy.nextSpellTime) {
            return;
        }

        const distance = Phaser.Math.Distance.Between(
            this.enemy.x, this.enemy.y,
            this.player.x, this.player.y
        );

        // Only cast if player is within range and there's line of sight
        if (distance < 300 && this.hasLineOfSight(this.enemy, this.player)) {
            this.enemy.isCasting = true;
            this.enemy.nextSpellTime = this.time.now + Phaser.Math.Between(1000, 2000);

            // Create casting circle indicator
            const castingCircle = this.add.circle(this.enemy.x, this.enemy.y, 20, 0xFF0000, 0.3);
            
            // Start casting animation
            this.tweens.add({
                targets: castingCircle,
                alpha: 0.6,
                yoyo: true,
                repeat: 2,
                duration: 350,
                onComplete: () => {
                    castingCircle.destroy();
                }
            });

            // After cast time, launch the spell
            this.time.delayedCall(700, () => {
                if (this.enemy.active) {
                    const spell = this.add.circle(this.enemy.x, this.enemy.y, 5, 0xFF0000);
                    this.physics.add.existing(spell);
                    
                    // Add to active spells group
                    this.activeSpells.add(spell);
                    
                    // Calculate lead target position based on player velocity
                    const leadFactor = 0.5;
                    const targetX = this.player.x + (this.player.body.velocity.x * leadFactor);
                    const targetY = this.player.y + (this.player.body.velocity.y * leadFactor);
                    
                    this.physics.moveTo(spell, targetX, targetY, 300);
                    
                    this.enemyStats.mana -= 20;
                    
                    // Add collisions
                    this.physics.add.collider(spell, this.walls, (spellObj) => {
                        this.createFizzleEffect(spellObj.x, spellObj.y);
                        spellObj.destroy();
                    });
                    
                    this.physics.add.collider(spell, this.houses, (spellObj) => {
                        this.createFizzleEffect(spellObj.x, spellObj.y);
                        spellObj.destroy();
                    });

                    // Check for hits on player
                    this.physics.add.overlap(spell, this.player, (spellObj) => {
                        this.playerStats.health = Math.max(0, this.playerStats.health - 20);
                        this.createFizzleEffect(spellObj.x, spellObj.y);
                        spellObj.destroy();
                    });

                    // Destroy spell after 1 second if it hasn't hit anything
                    this.time.delayedCall(1000, () => {
                        if (spell.active) {
                            this.createFizzleEffect(spell.x, spell.y);
                            spell.destroy();
                        }
                    });
                }
                
                this.enemy.isCasting = false;
            });
        }
    }

    hasLineOfSight(source, target) {
        const line = new Phaser.Geom.Line(source.x, source.y, target.x, target.y);
        const walls = this.walls.getChildren();
        const houses = this.houses.getChildren();
        
        // Check collision with walls and houses
        for (let wall of walls) {
            if (Phaser.Geom.Intersects.LineToRectangle(line, wall.getBounds())) {
                return false;
            }
        }
        for (let house of houses) {
            if (Phaser.Geom.Intersects.LineToRectangle(line, house.getBounds())) {
                return false;
            }
        }
        return true;
    }

    updateEnemyMovement() {
        const currentTime = this.time.now;
        
        // Check for nearby spells to avoid
        let nearestSpell = null;
        let nearestDistance = 100;
        
        this.spells?.forEach(spell => {
            if (spell.active) {
                const distance = Phaser.Math.Distance.Between(
                    this.enemy.x, this.enemy.y,
                    spell.x, spell.y
                );
                if (distance < nearestDistance) {
                    nearestSpell = spell;
                    nearestDistance = distance;
                }
            }
        });

        if (nearestSpell) {
            // Move perpendicular to spell direction
            const angle = Phaser.Math.Angle.Between(
                nearestSpell.x, nearestSpell.y,
                this.enemy.x, this.enemy.y
            );
            const perpAngle = angle + Math.PI / 2;
            
            this.enemy.body.setVelocity(
                Math.cos(perpAngle) * this.PLAYER_SPEED,
                Math.sin(perpAngle) * this.PLAYER_SPEED
            );
            
            this.enemy.avoidanceTimer = currentTime + 500;
        } else if (currentTime > this.enemy.avoidanceTimer) {
            // Normal movement behavior
            const distance = Phaser.Math.Distance.Between(
                this.enemy.x, this.enemy.y,
                this.player.x, this.player.y
            );

            if (distance > 200) {
                // Move closer to player
                this.physics.moveTo(this.enemy, this.player.x, this.player.y, this.PLAYER_SPEED * 0.8);
            } else if (distance < 150) {
                // Move away from player
                const angle = Phaser.Math.Angle.Between(
                    this.player.x, this.player.y,
                    this.enemy.x, this.enemy.y
                );
                this.enemy.body.setVelocity(
                    Math.cos(angle) * this.PLAYER_SPEED,
                    Math.sin(angle) * this.PLAYER_SPEED
                );
            } else {
                // Strafe around player
                const angle = Phaser.Math.Angle.Between(
                    this.player.x, this.player.y,
                    this.enemy.x, this.enemy.y
                );
                const strafeAngle = angle + Math.PI / 2;
                this.enemy.body.setVelocity(
                    Math.cos(strafeAngle) * this.PLAYER_SPEED,
                    Math.sin(strafeAngle) * this.PLAYER_SPEED
                );
            }
        }
    }

    update() {
        // Update player movement
        if (this.isMoving && this.pointer) {
            const distance = Phaser.Math.Distance.Between(
                this.player.x, this.player.y,
                this.pointer.x, this.pointer.y
            );

            // Add a small deadzone to prevent wiggling when cursor is very close
            if (distance < 5) {
                this.player.body.setVelocity(0, 0);
            } else {
                const angle = Phaser.Math.Angle.Between(
                    this.player.x, this.player.y,
                    this.pointer.x, this.pointer.y
                );
                
                const velocity = new Phaser.Math.Vector2();
                velocity.setToPolar(angle, this.PLAYER_SPEED);
                
                this.player.body.setVelocity(velocity.x, velocity.y);
            }
            
            // Update player shadow position
            this.playerShadow.setPosition(this.player.x + 5, this.player.y + 5);
        } else {
            this.player.body.setVelocity(0, 0);
        }

        // Update enemy shadow position
        this.enemyShadow.setPosition(this.enemy.x + 5, this.enemy.y + 5);

        // Update status bars position
        this.playerBars.setPosition(this.player.x, this.player.y - 40);
        this.enemyBars.setPosition(this.enemy.x, this.enemy.y - 40);

        // Update status bars scale
        this.playerHealthBar.scaleX = this.playerStats.health / 100;
        this.playerManaBar.scaleX = this.playerStats.mana / 100;
        this.enemyHealthBar.scaleX = this.enemyStats.health / 100;
        this.enemyManaBar.scaleX = this.enemyStats.mana / 100;

        // Regenerate health and mana
        this.playerStats.health = Math.min(100, this.playerStats.health + 0.1);
        this.playerStats.mana = Math.min(100, this.playerStats.mana + 0.2);
        this.enemyStats.health = Math.min(100, this.enemyStats.health + 0.1);
        this.enemyStats.mana = Math.min(100, this.enemyStats.mana + 0.2);

        // Update targeting indicator
        if (this.selectedTarget) {
            this.updateTargetingIndicator();
        }

        // Update enemy behavior
        this.updateEnemyMovement();
        this.enemyCastSpell();
    }
}

const config = {
    type: Phaser.AUTO,
    parent: 'gameCanvas',
    scale: {
        mode: Phaser.Scale.RESIZE,
        width: '100%',
        height: '100%'
    },
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false
        }
    },
    scene: MainScene
};

const game = new Phaser.Game(config);
</script>
</body>
</html>
